package keymaker

import (
	"crypto/tls"
	"log"
	"sync"
	"sync/atomic"
	"time"

	"github.com/valyala/gorpc"
)

// Client contacts one or more drones and generates keys
type Client struct {
	// Config contains client's configuration
	Config *ClientConfig

	// Workers holds the background workers requesting keys from drones
	workers map[string]*worker

	// TLS configuration for client connections
	tlsConfig *tls.Config

	// Lock synchronizing access to workers
	mu sync.Mutex
}

// Background worker that generates keys of a given type
type worker struct {
	keyType string
	ch      chan []byte
	exit    int32
	wg      sync.WaitGroup
}

// NewClient creates a client which contacts one or more drones
func NewClient(config *ClientConfig) (*Client, error) {
	tlsConfig, err := LoadClientTLSConfig(config.Dir, config)
	if err != nil {
		return nil, err
	}

	c := &Client{
		Config:    config,
		workers:   make(map[string]*worker),
		tlsConfig: tlsConfig,
	}
	return c, nil
}

// Generate creates or retrieves a channel which will emit keys.
// Keys are generated by background worker. This assumes you intend
// on generating large numbers of the given type of key.
func (c *Client) Generate(keyType string) <-chan []byte {
	c.mu.Lock()
	defer c.mu.Unlock()
	w := c.workers[keyType]
	if w == nil {
		w = c.newWorker(keyType)
		c.workers[keyType] = w
	}
	return w.ch
}

// Stop the client's background workers and close its channels
func (c *Client) Stop() {
	c.mu.Lock()
	defer c.mu.Unlock()
	for _, w := range c.workers {
		w.stop()
	}
	for _, w := range c.workers {
		w.wait()
	}
}

func (c *Client) newWorker(keyType string) *worker {
	ch := make(chan []byte, c.Config.BufferSize)
	w := &worker{
		keyType: keyType,
		ch:      ch,
	}
	for _, addr := range c.Config.Addresses {
		go w.start(addr, c.tlsConfig)
	}
	return w
}

func (w *worker) stop() {
	atomic.AddInt32(&w.exit, 1)
}

func (w *worker) wait() {
	w.wg.Wait()
	close(w.ch)
}

// Starts a client in the background, populating this worker's
// key channel.
func (w *worker) start(addr string, tlsConfig *tls.Config) {
	w.wg.Add(1)

	// TODO: add tls.Config
	client := gorpc.NewTLSClient(addr, tlsConfig)
	client.Start()

	resultCh := make(chan *gorpc.AsyncResult, 4)
	go func() {
		for atomic.LoadInt32(&w.exit) == 0 {
			req, err := client.CallAsync(w.keyType)
			if err != nil {
				log.Printf("drone %s async request error: %s", addr, err)
				<-time.After(time.Millisecond * 250)
			}

			resultCh <- req
		}
		close(resultCh)
	}()

	var res *gorpc.AsyncResult

	errors := 0
	limit := 3
	for {
		res = nil
		select {
		case res = <-resultCh:
		case <-time.After(time.Millisecond * 500):
			continue
		}

		if res == nil {
			log.Printf("%s %s worker received signal to exit", w.keyType, addr)
			break
		}

		<-res.Done
		if res.Error != nil {
			if errors < limit {
				log.Printf("drone %s error response %s", addr, res.Error)
			}
			errors++
			continue
		}

		if errors >= limit {
			log.Printf("drone %s generated %d additional error responses", addr, errors-limit)
		}
		errors = 0

		k, ok := res.Response.(*KeyResponse)
		if !ok {
			log.Printf("drone %s returned invalid response %T", addr, res.Response)
			<-time.After(time.Second)
			continue
		}

		if k.Error != ErrOK {
			log.Printf("drone %s returned remote error: %s", addr, k.Message)
			continue
		}

		w.ch <- k.Key
	}
	w.wg.Done()
}
