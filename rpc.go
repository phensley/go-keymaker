package keymaker

import (
	"encoding/pem"
	"fmt"
	"log"
	"runtime"
	"sync"
	"sync/atomic"
	"time"

	"github.com/valyala/gorpc"
)

// Client contacts one or more drones and generates keys
type Client struct {
	Config  *ClientConfig
	workers map[string]*worker
	mu      sync.Mutex // synchronize access to workers
}

// ClientConfig configures a drone client
type ClientConfig struct {
	BufferSize int      // number of keys to keep in the channel
	Addresses  []string // list of drone addresses
}

// Background worker that generates keys of a given type
type worker struct {
	keyType string
	ch      chan []byte
	exit    int32
	wg      sync.WaitGroup
}

// Drone defines an RPC service that generates keys
type Drone struct {
	Config  *DroneConfig
	service *gorpc.Server
}

// DroneConfig configures a Drone
type DroneConfig struct {
	Address     string
	Concurrency int
}

// DroneResponse is the response for a single RPC request
type DroneResponse struct {
	Key     []byte
	Error   int
	Message string
}

const (
	// ErrOK - no error occurred
	ErrOK = iota
	// ErrBadRequest - request was invalid
	ErrBadRequest
	// ErrKeyGen - key generation failed
	ErrKeyGen
)

func init() {
	gorpc.RegisterType(&DroneResponse{})
}

// NewClient creates a client which contacts one or more drones
func NewClient(config *ClientConfig) *Client {
	c := &Client{
		Config:  config,
		workers: make(map[string]*worker),
	}
	return c
}

// Generate creates or retrieves a channel which will emit keys.
// Keys are generated by background worker. This assumes you intend
// on generating large numbers of the given type of key.
func (c *Client) Generate(keyType string) <-chan []byte {
	c.mu.Lock()
	defer c.mu.Unlock()
	w := c.workers[keyType]
	if w == nil {
		w = c.newWorker(keyType)
		c.workers[keyType] = w
	}
	return w.ch
}

// Stop the client's background workers and close its channels
func (c *Client) Stop() {
	c.mu.Lock()
	defer c.mu.Unlock()
	for _, w := range c.workers {
		w.stop()
	}
	for _, w := range c.workers {
		w.wait()
	}
}

func (c *Client) newWorker(keyType string) *worker {
	ch := make(chan []byte, c.Config.BufferSize)
	w := &worker{
		keyType: keyType,
		ch:      ch,
	}
	for _, addr := range c.Config.Addresses {
		go w.start(addr)
	}
	return w
}

func (w *worker) stop() {
	atomic.AddInt32(&w.exit, 1)
}

func (w *worker) wait() {
	w.wg.Wait()
	close(w.ch)
}

// Starts a client in the background, populating this worker's
// key channel.
func (w *worker) start(addr string) {
	w.wg.Add(1)

	// TODO: add tls.Config
	client := gorpc.NewTCPClient(addr)
	client.Start()

	resultCh := make(chan *gorpc.AsyncResult, 4)
	go func() {
		for atomic.LoadInt32(&w.exit) == 0 {
			req, err := client.CallAsync(w.keyType)
			if err != nil {
				log.Printf("drone %s async request error: %s", addr, err)
				<-time.After(time.Millisecond * 250)
			}

			resultCh <- req
		}
		close(resultCh)
	}()

	var res *gorpc.AsyncResult

	errors := 0
	limit := 3
	for {
		res = nil
		select {
		case res = <-resultCh:
		case <-time.After(time.Millisecond * 500):
			continue
		}
		if res == nil {
			log.Printf("%s %s worker received signal to exit", w.keyType, addr)
			break
		}

		<-res.Done
		if res.Error != nil {
			if errors < limit {
				log.Printf("drone %s error response %s", addr, res.Error)
			}
			errors++
			continue
		}

		if errors >= limit {
			log.Printf("drone %s generated %d additional error responses", addr, errors-limit)
		}
		errors = 0

		k, ok := res.Response.(*DroneResponse)
		if !ok {
			log.Printf("drone %s returned invalid response %T", addr, res.Response)
			<-time.After(time.Second)
			continue
		}

		if k.Error != ErrOK {
			log.Printf("drone %s returned remote error: %s", addr, k.Message)
			continue
		}

		w.ch <- k.Key
	}
	w.wg.Done()
}

// NewDrone creates a Drone service
func NewDrone(config *DroneConfig) *Drone {
	d := &Drone{
		Config: config,
	}

	cc := config.Concurrency
	if cc <= 0 {
		cc = runtime.NumCPU()
	}

	d.service = gorpc.NewTCPServer(config.Address, d.handle)
	d.service.Concurrency = cc
	return d
}

// Start up the drone service
func (d *Drone) Start() error {
	return d.service.Serve()
}

// Receives a single RPC request and generates a response
func (d *Drone) handle(addr string, req interface{}) interface{} {
	if keyType, ok := req.(string); ok {
		payload, err := generateKey(keyType)
		if err == nil {
			return &DroneResponse{payload, ErrOK, ""}
		}
		return &DroneResponse{nil, ErrKeyGen, err.Error()}
	}
	return &DroneResponse{nil, ErrBadRequest, fmt.Sprintf("bad request: %v", req)}
}

// Generates a private key and returns the PEM-encoded PKCS#8
func generateKey(keyType string) ([]byte, error) {
	key, err := GeneratePrivateKey(keyType)
	if err != nil {
		return nil, err
	}
	data, err := MarshalPKCS8PrivateKey(key)
	if err != nil {
		return nil, err
	}
	return pem.EncodeToMemory(&pem.Block{
		Type:  "PRIVATE KEY",
		Bytes: data,
	}), nil
}
